
	<!doctype html>
	<html>

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Classes and Objects pt1</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/serif.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
				<section data-separator-vertical="^--" data-separator-notes="^Note:" data-markdown>
					<script type="text/template">
						# Introduktion till klasser och objekt

Note:
Dagens 칛mne 칛r klasser och objekt!

Vad 칛r det d친?

Vi k칬r ig친ng

---

## Vad 칛r en klass ?

--

En gruppering av funktioner och variabler

En mall som man skapar objekt fr친n
<!-- .element: class="fragment" -->

![OO](images/class-object-featured-image.png "OO")
<!-- .element: class="fragment" -->

Note:
Man kan se det p친 flera s칛tt

I grund och botten: en gruppering

men kan dock se det som en mall

--

### Varf칬r klasser?

Ni har jobbat med funktioner och variabler
<!-- .element: class="fragment" -->

Det kan bli gr칬tigt i stora projekt
<!-- .element: class="fragment" -->

Med klasser kan man dela upp koden modul칛rt
<!-- .element: class="fragment" -->

Man kan t칛nka sig koden som en upps칛ttning "grejer"
<!-- .element: class="fragment" -->

--
<!-- .slide: data-transition="fade" -->

### Klassens anatomi

***Klasser*** har ***namn***

```cpp[1]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		...
	}
};
```

--
<!-- .slide: data-transition="fade" -->

### Klassens anatomi

***Medlemsvariabler***

```cpp[2]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		...
	}
};
```
Note:
Dags f칬r ett exempel!

--
<!-- .slide: data-transition="fade" -->

### Klassens anatomi

***Medlemsfunktioner***

```cpp[4-6]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		...
	}
};
```
Note:
Medlemsfunktioner kan ocks친 kallas metoder. Jag har (o)vanan att anv칛nda det ordet.

--
<!-- .slide: data-transition="fade slide-out" -->

### Klassens anatomi

***Funktioner*** i ett objekt kan ***n친 variabler*** i ***objektet***

```cpp[4-6]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		piIsh = 22.0f / 7.0f;
	}
};
```
Note:
Vad 칛r d친 Objekt
--
<!-- .slide: data-transition="slide-in fade-out" -->

Hur skapar man objekt fr친n klasser?

```cpp[10]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		piIsh = 22.0f / 7.0f;
	}
};

int main() {
    SomeClass myClass;
}
```
<!-- .element: class="fragment" -->

```bash[2-3]
Warning(s):
s.cpp:11:15: warning: unused variable 'myClass' [-Wunused-variable]
    SomeClass myClass;
              ^
1 warning generated.
```
<!-- .element: class="fragment" -->

Note:
Objekt 칛r , som vi sa tidigare, en instans av en klass

--
<!-- .slide: data-transition="fade" -->

Hur anv칛nder man objekt?

```cpp[11]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		piIsh = 22.0f / 7.0f;
	}
};

int main() {
    SomeClass myClass;
    myClass.calcPiIsh();
}

```

```bash[2-3|5]
Error(s):
s.cpp:11:13: error: 'calcPiIsh' is a private member of 'SomeClass'
    myClass.calcPiIsh();
            ^
s.cpp:4:10: note: implicitly declared private here void calcPiIsh(){
         ^
1 error generated.
```
<!-- .element: class="fragment" -->

--
<!-- .slide: data-transition="fade" -->

Och hur fixar man det d칛r kompileringsfelet?

```cpp[2,5]
class SomeClass {
 private:
  float piIsh;

 public:
  void calcPiIsh() { piIsh = 22.0f / 7.0f; }
};

int main() {
    SomeClass myClass;
    myClass.calcPiIsh();
}


```
<!-- .element: class="fragment" -->

```bash
Compilation time: 0.25 sec
```
<!-- .element: class="fragment" -->

---

## Vad 칛r `private` och `public`?

--

`private` - medlemmar n친bara *endast inom* klassen

`public` - medlemmar n친bara *utanf칬r* klassen
<!-- .element: class="fragment" -->

Medlemmar i en ***klass*** 칛r `private` om inget annat anges
<!-- .element: class="fragment" -->

--

### Varf칬r `public`/`private`?

F칬r att strukturera upp koden
<!-- .element: class="fragment" -->

Ger m칬jlighet till *Abstraktion* och *Inkapsling*
<!-- .element: class="fragment" -->

--

### Abstraktion

*Anv칛ndaren beh칬ver inte veta vad som h칛nder under huven*
<!-- .element: class="fragment" -->

* Vet du hur en bils f칬rbr칛nningsmotor fungerar? <!-- .element: class="fragment" -->
* Beh칬ver du veta det? <!-- .element: class="fragment" -->
* R칛cker det med att veta vad som h칛nder n칛r du trycker p친 gaspedalen?<!-- .element: class="fragment" -->


--

### Inkapsling (Encapsulation)

*Saker som h칛nger ihop ska samlas*
<!-- .element: class="fragment" -->

Note:
H칛r skulle exemplet kunna vara:
Bil som klass
Bra att ha hjkul, d칬rrar, gaspedaler etc i samma klass,
samlat 
--

### Ett exempel

--

```cpp[|2-9|10-22|3-4|6-9|11-22]
class Car {
  private:
	float speed;
	float maxSpeed;
  
	void sanityCheckSpeed(){
		if (speed &lt; 0) speed = 0.0f;
		if (speed &gt; maxSpeed) speed = maxSpeed;
	}
  public:
	void setup(float p_maxSpeed){
		speed = 0.0f;
		maxSpeed = p_maxSpeed;
	}
	void accelerate(float pedalFactor){
		speed += 10 * pedalFactor;
		sanityCheckSpeed();
	}
	void applyBreak(float pedalFactor){
		speed -= 10 * pedalFactor;
		sanityCheckSpeed();
	}
};
```
<!-- .element: class="r-stretch" -->

--

### Nu provk칬r vi!

```cpp[6 | 7| 9-11 | 12-13]
class Car {
  ...
};

int main() {
    Car minVolvo242Gl;
    minVolvo242Gl.setup(120);
    
    minVolvo242Gl.accelerate(1.0f); // Full gas!
    minVolvo242Gl.accelerate(1.0f); // Bra drag!
    minVolvo242Gl.accelerate(1.0f); // Nu b칬rjar det g친 lite fort..
    minVolvo242Gl.applyBreak(42.0f); // R친djur!!!
    minVolvo242Gl.applyBreak(1.0f); // Puh!!! Vi 칬verlevde!
}
```

---

## Konstruktorer

--

```cpp[7-8]
class Car {
  ...
};

int main() {
    Car minVolvo242Gl;
    minVolvo242Gl.setup(120);
    
    minVolvo242Gl.accelerate(1.0f); // Full gas!
    minVolvo242Gl.accelerate(1.0f); // Bra drag!
    minVolvo242Gl.accelerate(1.0f); // Nu b칬rjar det g친 lite fort..
    minVolvo242Gl.applyBreak(42.0f); // R친djur!!!
    minVolvo242Gl.applyBreak(1.0f); // Puh!!! Vi 칬verlevde!
}
```
hmm... inte s친 najs
<!-- .element: class="fragment" -->

--

### Konstruktorer...

K칬rs n칛r objekt skapas
<!-- .element: class="fragment" -->

Kan anv칛ndas tll att ***tvinga medlemsvariabler*** att bli ***initialiserade***
<!-- .element: class="fragment" -->

--

```cpp[1,11-14]
class Car {
  private:
	float speed;
	float maxSpeed;
  
	void sanityCheckSpeed(){
		if (speed &lt; 0) speed = 0.0f;
		if (speed &gt; maxSpeed) speed = maxSpeed;
	}
  public:
	Car(float p_maxSpeed){
		speed = 0.0f;
		maxSpeed = p_maxSpeed;
	}
	void accelerate(float pedalFactor){
		speed += 10 * pedalFactor;
		sanityCheckSpeed();
	}
	void applyBreak(float pedalFactor){
		speed -= 10 * pedalFactor;
		sanityCheckSpeed();
	}
};
```
<!-- .element: class="r-stretch" -->

--

### Nu provk칬r vi igen!

```cpp[6]
class Car {
  ...
};

int main() {
    Car minNyaVolvo242Gl(120);
    
    minNyaVolvo242Gl.accelerate(1.0f); // Full gas!
    minNyaVolvo242Gl.accelerate(1.0f); // Bra drag!
    minNyaVolvo242Gl.accelerate(1.0f); // Det b칬rjar g친 lite fort..
    minNyaVolvo242Gl.applyBreak(42.0f); // R친djur!!!
    minNyaVolvo242Gl.applyBreak(1.0f); // Puh!!! Vi 칬verlevde!
}
```
Najsigare!

--

### Om jag vill ha flera bilar d친?

--

```cpp[6]
class Car {
  ...
};

int main() {
    Car cars[10];
}
```

--

```bash[2-3 | 5-14]
Error(s):
s.cpp:24:9: error: no matching constructor for initialization of 'Car [10]'
    Car cars[10];
        ^
s.cpp:11:5: note: candidate constructor not viable: \
		requires single argument 'maxSpeed'&#44; but no arguments were provided
    Car(float maxSpeed) : maxSpeed(maxSpeed){}
    ^
s.cpp:1:7: note: candidate constructor (the implicit copy constructor) \
		not viable: requires 1 argument&#44; but 0 were provided \
class Car {
      ^
s.cpp:1:7: note: candidate constructor (the implicit move constructor) \
	not viable: requires 1 argument&#44; but 0 were provided \
1 error generated.
```
<!-- .element: class="r-stretch" -->

--

```cpp[11-14]
class Car {
  private:
	float speed;
	float maxSpeed;
	
	void sanityCheckSpeed(){
		if (speed &lt; 0) speed = 0.0f;
		if (speed &gt; maxSpeed) speed = maxSpeed;
	}
  public:
	Car(){
        speed = 0.0f;
        maxSpeed = 100;
    }
	Car(float p_maxSpeed){
        speed = 0.0f;
        maxSpeed = p_maxSpeed;
    }
	void accelerate(float pedalFactor){
		speed += 10 * pedalFactor;
		sanityCheckSpeed();
	}
	void applyBreak(float pedalFactor){
		speed -= 10 * pedalFactor;
	  	sanityCheckSpeed();
	}
};
```
<!-- .element: class="r-stretch" -->

```bash
Compilation time: 0.23 sec
```
<!-- .element: class="fragment" -->

Note:
Vi skapar en till ctor
en default-ctor
--

### Varf칬r fungerade det innan?

Kompilatorn skapade en *default-konstruktor* 친t oss
<!-- .element: class="fragment" -->

De f칬rsvinner n칛r man skapar egna konstruktorer
<!-- .element: class="fragment" -->

Man kan be kompilatorn skapa en dock
<!-- .element: class="fragment" -->

--

Exempel:

```cpp[6]
class SomeClass {
 private:
  float piIsh;

 public:
  SomeClass() = default;
  SomeClass(float customPi) { piIsh = customPi; }
};

int main(){
    SomeClass myPis[42];
    SomeClass myPi(22.0f / 7.0f);
}

```

```bash
Compilation time: 0.22 sec
```
<!-- .element: class="fragment" -->

--

Man kan ocks친 be kompilatorn ta bort en konstruktor

--

Exempel:

```cpp[6 | 12]
class SomeClass {
 private:
  float piIsh;

 public:
  SomeClass(int customPi) = delete;
  SomeClass(float customPi) { piIsh = customPi; }
};

int main(){
    SomeClass myPi(22.0f / 7.0f);
    SomeClass mySecondPi(42);
}
```

```bash[2-3|5-6]
Error(s):
s.cpp:13:15: error: call to deleted constructor of 'SomeClass'
    SomeClass mySecondPi(42);
              ^          ~~
s.cpp:5:2: note: 'SomeClass' has been explicitly marked deleted here
        SomeClass(int customPi) = delete;
        ^
1 error generated.
```
<!-- .element: class="fragment" -->

Note:
Vad 칛r det bra f칬r?
Man kan kr칛va en viss datatyp, ex ett flyttal
--

### Varf칬r ska man ha en konstruktor?

F칬r att ***initiera*** variabler
<!-- .element: class="fragment" -->

Annars f친r de ***slumpm칛ssiga*** v칛rden
<!-- .element: class="fragment" -->

--

Exempel:

```cpp[]
#include &lt;iostream&gt;

class SomeClass {
 private:
  float piIsh;

 public:
  SomeClass() = default;
  SomeClass(float customPi) { piIsh = customPi; }
  void print() { std::cout &lt;&lt; "pi: " &lt;&lt; piIsh &lt;&lt; "\n"; }
};

int main(){
    SomeClass myPis[3];
    for( SomeClass pi : myPis){
        pi.print();
    }
}
```
<!-- .element: class="r-stretch" -->

--

```bash
mattias@Osborne1:/mnt/c/temp$ clang++ -std=c++11 test.cpp -o test
mattias@Osborne1:/mnt/c/temp$ ./test
pi: -9.92432e+17
pi: 4.59163e-41
pi: 0
```

Om man ***inte initierar*** en variabel kommer den f친 det ***v칛rde*** som ligger p친 dess plats i ***minnet*** sen ***tidigare***!
<!-- .element: class="fragment" -->

--

### Kan vara j칛tted친ligt!

* Best case: Konstiga buggar
<!-- .element: class="fragment" -->
* Worst case: Rej칛la s칛kerhetsh친l
<!-- .element: class="fragment" -->

Ex:
https://www.usenix.org/conference/woot20/presentation/cho
<!-- .element: class="fragment" -->


---

## 칐verlagring

--

Eller: 

***Flera medlemsfunktioner*** som heter ***likadant***

--

Det fungerar 칛ven p친 vanliga funktioner...

```cpp
#include &lt;iostream&gt;

int f(){ return 42; }
int f(int i){ return i; }

int main(){
    std::cout&lt;&lt;f()&lt;&lt;"\n";
    std::cout&lt;&lt;f(7)&lt;&lt;"\n";
}
```

```bash
Compilation time: 0.52 sec&#44; absolute running time: 0.16 sec

42
7

```

--

### Vad h칛nder under huven?

I ***kompileringen*** kommer namn att ***manglas***

* `int f()` blir `_Z1fv` <!-- .element: class="fragment" -->
* `int f(int i)` blir  `_Z1fi` <!-- .element: class="fragment" -->

Note:
fv, funktionens namn och void
- void som i tomhet
- void, precis som returv칛rdet

fi, funktionens namn och int

Notera att returv칛rdet ej finns med i manglingen

Exemplet ovan 칛r fr친n Linux/GCC
--

### Varf칬r mangling

D친 vet l칛nkaren vilken ***version*** av funktionen du anropar


---

## Variablers *scope*

--

<!-- .slide: data-transition="slide-in fade" -->

```cpp[6]
class Car {
 private:
  float speed;
  float maxSpeed;
  ...
  Car(float p_maxSpeed) {
    speed = 0.0f;
    maxSpeed = p_maxSpeed;
  }
  ...
};
```

Varf칬r heter `p_maxSpeed`, inte `maxSpeed`... ?

--
<!-- .slide: data-transition="fade" -->

```cpp[4,8]
class Car {
 private:
  float speed;
  float maxSpeed;
  ...
  Car(float p_maxSpeed) {
    speed = 0.0f;
    maxSpeed = p_maxSpeed;
  }
  ...
};
```

En medlemsvariabel heter redan `maxSpeed`

--
<!-- .slide: data-transition="fade slide-out" -->

```cpp[4,6,8]
class Car {
 private:
  float speed;
  float maxSpeed;
  ...
  Car(float p_maxSpeed) {
    speed = 0.0f;
    maxSpeed = p_maxSpeed;
  }
  ...
};
```
Om medlemsvariabeln inte ska ***g친 ur scope*** m친ste parametern heta n친got annat

--

Typ `p_maxSpeed`

Eller...
<!-- .element: class="fragment" -->


---

## `this`

--

Ett ***nyckelord*** (***keyword***) som fungerar som en ***pekare*** till det ***aktuella objektet***

--

N칛r du i en ***medlemsfunktion*** anv칛nt dig av en annan ***medlem*** har `this` ***implicit*** anv칛nts

--

D.v.s., kompilatorn har lagt till `this` 친t dig

--

```cpp[5]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		piIsh = 22.0f / 7.0f;
	}
};
```

칛r allts친 egentligen
<!-- .element: class="fragment" -->

```cpp[5]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		(*this).piIsh = 22.0f / 7.0f;
	}
};
```
<!-- .element: class="fragment" -->

--

### `(*pointer).`

kan ocks친 skrivas som

### `pointer->`

--

```cpp[5]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		(*this).piIsh = 22.0f / 7.0f;
	}
};
```

칛r allts친 samma som

```cpp[5]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		this-&gt;piIsh = 22.0f / 7.0f;
	}
};
```

--

De betyder ***samma sak***, men

### `->`

***f칬redras*** oftast

--

`this` kan ocks친 anv칛ndas n칛r en ***parameter*** har ***samma namn*** som en ***medlemsvariabel***

--
<!-- .slide: data-transition="slide-in fade-out" -->
Som i fallet med klassen `Car`

```cpp[6,8]
class Car {
 private:
  float speed;
  float maxSpeed;
  ...
  Car(float p_maxSpeed) {
    speed = 0.0f;
    maxSpeed = p_maxSpeed;
  }
  ...
};
```

--
<!-- .slide: data-transition="fade" -->

som blir

```cpp[6-8]
class Car {
 private:
  float speed;
  float maxSpeed;
  ...
  Car(float maxSpeed) {
    speed = 0.0f;
    this-&gt;maxSpeed = maxSpeed;
  }
  ...
};
```

Note:
H칛r ber칛ttar vi f칬r kompilatorn att:
- just instansens variabel av namnet
- som ska tilldelas v칛rdet fr친n parametern

---

## Initialiseringslistor

--

Ett annat s칛tt att initialisera medlemsvariabler

--

```cpp[6-9]
class Car {
 private:
  float speed;
  float maxSpeed;
  ...
  Car(float maxSpeed) {
    speed = 0.0f;
    this-&gt;maxSpeed = maxSpeed;
  }
  ...
};

```

blir
<!-- .element: class="fragment" -->

```cpp[6]
class Car {
 private:
  float speed;
  float maxSpeed;
  ...
  Car(float maxSpeed) : speed(0.0f)&#44; maxSpeed(maxSpeed){}
  ...
};
```
<!-- .element: class="fragment" -->

--

### F칬rdelar?

Prestanda*
<!-- .element: class="fragment" -->

F칛rre kopieringar -> h칬gre prestanda
<!-- .element: class="fragment" -->

\*Kompilatorn ***kan*** dock optimera bort kopieringar ***sj칛lv***
<!-- .element: class="fragment" -->

--

### F칬rdelar?

Mindre risk f칬r fel

Det h칛nder att man gl칬mmer `this`  exempelvis
<!-- .element: class="fragment" -->


---

## Konstanter

--

(som ni kanske vet)

**`const`** g칬r att variabel ***inte*** kan ***칛ndras*** efter att den ***skapats***
<!-- .element: class="fragment" -->

Det blir allts친 en konstant
<!-- .element: class="fragment" -->

--

**`const`** kan anv칛ndas b친de till ***medlemsvariabler***, ***parametrar*** och ***medlemsfunktioner*** 

--

Ex:

```cpp[4]
class Car {
 private:
  float speed;
  float maxSpeed;
  ...
  Car(float maxSpeed) {
    speed = 0.0f;
    this-&gt;maxSpeed = maxSpeed;
  }
  ...
};
```

--

Blir

```cpp[4]
class Car {
 private:
  float speed;
  const float maxSpeed;
  ...

 public:
  Car(float maxSpeed) {
    speed = 0.0f;
    this-&gt;maxSpeed = maxSpeed;
  }
  ...
  };
```

--

### Men det kompilerar ju inte?!

```bash[2-4 | 9-12]
Error(s):
1172188222/source.cpp:11:2: error: constructor for 'Car' must explicitly \
	initialize the const member 'maxSpeed'
        Car(float p_maxSpeed){
        ^
1172188222/source.cpp:4:14: note: declared here
        const float maxSpeed;
                    ^
1172188222/source.cpp:12:12: error: cannot assign to non-static data \
	member 'maxSpeed' with const-qualified type 'const float'
                maxSpeed = p_maxSpeed;
                ~~~~~~~~ ^
1172188222/source.cpp:4:14: note: non-static data member 'maxSpeed' \
	declared const here
        const float maxSpeed;
        ~~~~~~~~~~~~^~~~~~~~
2 errors generated.

```
<!-- .element: class="r-stretch" -->

--

Kompileringsfelet fixar man med ***initialiseringslistor***!

```cpp[8]
class Car {
 private:
  float speed;
  const float maxSpeed;
  ...

 public:
  Car(float maxSpeed) : speed(0.0f)&#44; maxSpeed(maxSpeed){}
  ...
};
```
<!-- .element: class="fragment" -->

--

### `const`-parametrar

Parametrar som 칛r **`const`** kan ***inte*** modifieras ***i funktionen***

```cpp[8]
class Car {
 private:
  float speed;
  const float maxSpeed;
  ...

 public:
  Car(const float maxSpeed) : speed(0.0f)&#44; maxSpeed(maxSpeed){}
  ...
};
```
<!-- .element: class="fragment" -->

--

### `const`-medlemsfunktioner

En ***medlemsfunktion*** som 칛r **`const`** kan ***inte*** modifiera ***medlemsvariabler***

```cpp[8]
class Car {
 private:
  float speed;
  const float maxSpeed;
  ...

 public:
  float getSpeed() const { return speed; }
  ...
};
```
<!-- .element: class="fragment" -->

--

### Vad 칛r `const` bra f칬r?

* F칛rre buggar <!-- .element: class="fragment" -->
* Visar om du har sidoeffekter <!-- .element: class="fragment" -->
* Hj칛lper kompilatorn att optimera <!-- .element: class="fragment" -->

---

## `static` 

--

Hittills har alla funktioner och variabler varit ***medlemmar*** i klassen
--

De har varit ***knutna*** till en specifik ***instans*** 

--

Ex:

```cpp
class Car{...};

Car volvoPv(100);

Car saab900Turbo(200);

Car koeniggseggJeskoAbsolut(483);
```

--

Med **`static`** kan man skapa ***funktioner*** och ***variabler*** som ***delas*** av alla instanser av en ***klass***

--

### Ett exempel

```[5|8-10|13|16]cpp
#include &lt;iostream&gt;

class MphConverter {
  private:
	static const float mphToKmhFactor;

  public:
	static float toKmh(float mph){
		return mph*mphToKmhFactor;
	}
};

const float MphConverter::mphToKmhFactor = 1.60934;

int main(){
	std::cout&lt;&lt;"60 mph is "&lt;&lt;MphConverter::toKmh(60)&lt;&lt;" Kmh";
}
```
<!-- .element: class="r-stretch" -->

```
60 mph is 96.5604 Kmh
```
<!-- .element: class="fragment" -->

Note:
- F칬rst skapar vi en variabel som delas av alla instanser av klassen (objekt)
- Den 칛r dessutom const

- Sen har vi en statisk medlemsfunktion som delas av alla instanser (objekt)
- Den anv칛nder variabeln ovan

---

## Delegerande Konstruktorer

--

Ibland beh칬ver man ***친teranv칛nda*** logik fr친n en konstruktor i en ***annan***

Med ***delegerande*** konstruktorer ***anropar*** man ***en annan*** konstruktor
<!-- .element: class="fragment" -->

Ungef칛r som i en initialiseringslista
<!-- .element: class="fragment" -->
--

### Exempelvis:

```cpp[8,9,13-14|10-11, 15-16]
class Car {
  private:
    std::string makeAndModel
	float maxSpeed;
	float speed;
	...
  public:
	Car() : speed(0.0f)&#44; maxSpeed(100){}
    Car(float maxSpeed) : speed(0.0f){
        if (maxSpeed &gt; 240) maxSpeed = 240;
        if (maxSpeed &lt; 0) maxSpeed = 100;
    }
    Car(float maxSpeed&#44; std::string makeAndModel)
		: speed(0.0f)&#44; makeAndModel(makeAndModel){
        if (maxSpeed &gt; 240) maxSpeed = 240;
        if (maxSpeed &lt; 0) maxSpeed = 100;
    }
};
```
<!-- .element: class="r-stretch" -->

Note:
I det h칛r exemplet har vi tre konstruktorer.

Kod f칬r att se till att maxSpeed 칛r rimlig 칛r duplicerad i tv친 av konstruktorerna.

I 칬vrigt anv칛nds initialiseringslistor f칬r 칬vriga medlemsvariabler.

--

Blir:

```cpp[ 8 | 9 | 10-11 | 13 | 14]
class Car {
  private:
    std::string makeAndModel
	  float maxSpeed;
	  float speed;
	  ...
  public:
	Car() : speed(0.0f)&#44; maxSpeed(100){}
    Car(float maxSpeed) : Car() {
        if (maxSpeed &gt; 240) maxSpeed = 240;
        if (maxSpeed &lt; 0) maxSpeed = 100;
    }
    Car(float maxSpeed&#44; std::string makeAndModel): Car(maxSpeed){
        this-&gt;makeAndModel = makeAndModel;
    }
};
```
<!-- .element: class="r-stretch" -->

Note:
- F칬rsta konstruktorn ser identisk ut

- Andra konstruktorn har kvar koden som var duplicerad
- Anv칛nder sig av f칬rsta konstruktorn f칬r att s칛tta speed till ett defaultv칛rde

- Tredje konstruktorn anropar konstruktor nr2
    - slippa duplicera kod
    - S칛tter makeAndModel manuellt

Man kan inte blanda initialiseringslistor och delegerande konstruktorer.

--

### Pros & Cons

Logik kan ***친teranv칛ndas***
<!-- .element: class="fragment" -->

Kan ***inte*** kombineras med ***initialiseringslistor***
<!-- .element: class="fragment" -->


---

## **`struct`**

--

Som en klass *typ*

Men, allt 칛r **`public`** ist칛llet f칬r **`private`** per ***default***
<!-- .element: class="fragment" -->

--

```cpp[1]
class SomeClass {
	float piIsh;

	void calcPiIsh(){
		piIsh = 22.0f / 7.0f;
	}
};
```

blir

```cpp[1]
struct SomeStruct {
	float piIsh;

	void calcPiIsh(){
		piIsh = 22.0f / 7.0f;
	}
};
```

--

### N칛r ska man anv칛nda sig av `struct` ?

N칛r du vill ***gruppera data*** utan allt f칬r mycket ***funktionalitet***. 
<!-- .element: class="fragment" -->

Note:
Man tappar s칛kerhet med get-funktioner som har const ex dock

St칬rre risk att man av misstag 칛ndrar ett v칛rde

--

Exempelvis f칬r ***aggregatklasser***


---

## Aggregatklasser

--

### En klass utan
1. Konstruktorer (och destruktorer)*
<!-- .element: class="fragment" -->
1. Privata icke-statiska medlemmar
<!-- .element: class="fragment" -->
1. Arv (basklasser och virtuella funktioner)*
<!-- .element: class="fragment" -->

*Vi kommer g친 igenom vad detta 칛r vid en senare f칬rel칛sning 游
<!-- .element: class="fragment" -->

--

F칬rdel? De kan initieras med en ***initialiseringslista***

--
### Ett exempel:
```cpp[1|5|2|6]
struct Vec3f { float x&#44; y&#44; z; };
struct Box { Vec3f min&#44; max; };

int main(){
	Vec3f myVec{1.0f&#44; 0.0f&#44; 0.0f};
	Box myBox = { {1.0f&#44; 2.0f&#44; 3.0f}&#44; {2.0f&#44; 3.0f&#44; 4.0f} };
}

```

---

## Aliasing

Note:
Vi ger en typ (ett heltal, float, klass etc) ett alias

--

### Exempelvis:

```cpp
typedef int cm;
```

eller

```cpp
using cm = int;
```

--

Anv칛nds som **`typ`**:

```cpp
using cm = int;

struct Box {
    cm length;
    cm height;
    cm width;
};
```

--

### Praktiska att anv칛nda ihop med klasser

```cpp[2, 10]
struct Box {
    using cm = int;
    cm length;
    cm height;
    cm width;
};

int main(){
    Box b;
    Box::cm length = 20;
    b.length = length;
}
```

--

### Nackdelar

```cpp[1,2|12,13]
using inch = int;
using cm = int;

struct Box {
    cm length;
    cm height;
    cm width;
};

int main(){
    Box b;
    inch length = 20;
    b.length = length;
}
```
Note:
I det h칛r exemplet

Tv친 alias f칬r samma typ

Den ena kan anv칛ndas ist칛llet f칬r den andra

Man f친r ingen varning
--

Alias 칛r ***inte*** riktiga ***starka typer***, de 칛r ***svaga typer***

(engelska: ***strong*** - ***weak***)
<!-- .element: class="fragment" -->


---

## `inline`

***Tipsar*** om att en funktion kan ***inlineas***

--

Vid ***inlining*** ers칛tts funktionsanropet med en ***copy-paste*** av funktionsdefinitionen

--

### Ett exempel:

```cpp[]
inline int add(int a, int b){
    return a+b;
}

int main(){
    int result = add (43, 1338);
}
```

blir:
<!-- .element: class="fragment" -->

```cpp
int main(){
    int result = 43 + 1338;
}
```
<!-- .element: class="fragment" -->

--

I verkligheten kommer din ***kompilator*** sj칛lv ***avg칬ra*** vad som inlineas och inte

**`inline`** 칛r ett ***tips*** till kompilatorn, ***ingen instruktion***

--

`inline` kan dock anv칛ndas f칬r att definera samma funtion flera g친nger ***(j칛ttefarligt!)***

--

### Exempelvis:

```cpp[]
// add.hpp
inline int add(int a, int b){
    return a+b;
}

// foo.hpp
int foo(int a, int b);

// foo.cpp
#include "add.hpp"
int foo(int a, int b){
    return add(a,b);
}

// main.cpp
#include "add.hpp" 
#include "foo.hpp" 
int main(){
    return foo (43, 3);
}
```
<!-- .element: class="r-stretch" -->

Note:
Tv친 headerfiler
    - add funktionsdefinition
    - foo funktionsdeklaration

tv친 k칛llfiler
    - foo, funktionsdefinition, anv칛nder add
    - main, anv칛nder foo. Inkluderar b친de foo.hpp och add.hpp

Notera: inga includeguards!
--

```bash[]
clang++ -c foo.cpp && clang++ -c main.cpp && clang++ main.o foo.o
/usr/bin/ld: foo.o: in function `add(int, int)':
foo.cpp:(.text+0x0): multiple definition of `add(int, int)'; \
    main.o:main.cpp:(.text+0x0): first defined here
clang: error: linker command failed with exit code 1 (use -v to \
    see invocation)
```

Note:
#include-direktivet g칬r ju en copy-paste av headern in i k칛llfilen 

main.o och foo.o (en objektfil per k칛llfil) kommer f친 varsin version av add()

L칛nkaren, som l칛nkar samman objektfilerna, kommer gn칛lla d친 den hittar tv친 definitioner av samma funktion
--

```cpp[2]
// add.hpp
inline int add(int a, int b){
    return a+b;
}

// foo.hpp
int foo(int a, int b);

// foo.cpp
#include "add.hpp"
int foo(int a, int b){
    return add(a,b);
}

// main.cpp
#include "add.hpp" 
#include "foo.hpp" 
int main(){
    return foo (43, 3);
}
```

--

```bash
clang++ foo.cpp main.cpp && ./a.out ; echo $?
46
```

Note:
L칛nkaren vet att det kan finnas flera definitioner, tack vara inline

allt 칛r frid och fr칬jd

Vi kan k칬ra programmet och returv칛rdet st칛mmer bra (43+3)

---

## Best practices

--

###  `.hpp` och `.cpp`

Du b칬r l칛gga din ***klassdeklaration*** i en `*.hpp`-fil
<!-- .element: class="fragment" -->

Du b칬r l칛gga din ***klassdefinition*** i en `*.cpp`-fil
<!-- .element: class="fragment" -->

--
***Klassdeklaration*** i **`Car.hpp`**:

```cpp[|6,11-13|9-10]
class Car {
 private:
  float speed;
  const float maxSpeed;

  void sanityCheckSpeed();

 public:
  Car() : speed(0.0f)&#44; maxSpeed(100) {}
  Car(const float maxSpeed) : speed(0.0f)&#44; maxSpeed(maxSpeed) {}
  void accelerate(float pedalFactor);
  void applyBreak(float pedalFactor);
  float getSpeed() const;
};
```

--

***Klassdefinition*** i **`Car.cpp`**:

```cpp[|3,8,13,18]
#include "Car.hpp"

void Car::sanityCheckSpeed() {
  if (speed &lt; 0) speed = 0.0f;
  if (speed &gt; maxSpeed) speed = maxSpeed;
}

void Car::accelerate(float pedalFactor) {
  speed += 10 * pedalFactor;
  sanityCheckSpeed();
}

void Car::applyBreak(float pedalFactor) {
  speed -= 10 * pedalFactor;
  sanityCheckSpeed();
}

float Car::getSpeed() const { return speed; }
```
<!-- .element: class="r-stretch" -->

--

### Ska man ha `public` eller `private` f칬rst?

Spelar ingen roll!
<!-- .element: class="fragment" -->

--

Public f칬rst-exempel:
```cpp
class Car {
 public:
  Car() : speed(0.0f)&#44; maxSpeed(100) {}
  Car(const float maxSpeed) : speed(0.0f)&#44; maxSpeed(maxSpeed) {}
  void accelerate(float pedalFactor);
  void applyBreak(float pedalFactor);
  float getSpeed() const;

 private:
  float speed;
  const float maxSpeed;

  void sanityCheckSpeed();
};
```

--
### F칬rdelar?

L칛ttare att f칬rst친 ditt API f칬r andra
<!-- .element: class="fragment" -->

### Nackdelar?

Medlemsfunktioner hamnar f칬re sina variabler
<!-- .element: class="fragment" -->

--

V칛lj en stil och f칬lj den ***konsekvent***!

--

### Anv칛nd initialiseringlistor!

Risken f칬r buggar minskar rej칛lt
<!-- .element: class="fragment" -->

					</script>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				slideNumber: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
			});
		</script>
	</body>

	</html>